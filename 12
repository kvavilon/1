#include <iostream>

using namespace std;

class IntNode{
                                            public:
                                                int value;
                                                int info;
                                                IntNode *next, *prev;
                                                IntNode(int value, IntNode *next=NULL){
                                                this->value=value;
                                                this->next=next;
                                                }

                                            };

                                            class IntList{

                                                private:
                                                IntNode *head, *tail;

                                                public:

                                                IntList();

                                                ~IntList();

                                            bool deleteFrontHead(int &el);

                                            bool IsEmpty();

                                            void dodawanie(int el);

                                            void wyswietlanie();

                                            bool isInList(int el);

              bool deleteFromTail(int &el);
    };

IntList::IntList(){
    head=tail=NULL;
    }

IntList::~IntList(){
    while(head != NULL){
        IntNode *temp = head-> next;
        delete head;
        head=temp;
    }
    }

void IntList::wyswietlanie(){
IntNode*temp=head;
while (temp){
    cout<< temp->value<<" ";
    temp=temp->next;
}
//cout<<endl;
}

bool IntList::IsEmpty(){
if (head == NULL) return true;
return false;
}

void IntList::dodawanie(int el){
if (IsEmpty()){
    head=tail=new IntNode(el);
}
else {
    tail->next=new IntNode(el);
    tail=tail -> next;
}

}


bool IntList::isInList(int el){

IntNode *temp = head;
while (temp){
    if (temp -> value == el)
        return temp;
    temp = temp->next;
}
return false;
}

bool IntList::deleteFrontHead(int &el){
  IntNode *tail=head;
  if(!head) return 0;
  else {
    el=head -> value;
    head=tail->next;
    delete tail;
    return 1;
  }
}

bool IntList::deleteFromTail(int &el){
if(IsEmpty()){
    return false;
}
else if(head == tail){
    el=tail->value;
    delete tail;
    head = tail = NULL;
    return true;
}
else{
    IntNode *temp = head;
    while(temp->next!=tail){
        temp=temp->next;
    }
    el = tail->value;
    delete tail;
    tail=temp;
    tail->next=NULL;
    return true;
}
}

//dzewo
class BSTNode{
    public:
    IntList list;
    string value="";

    BSTNode *lSon, *rSon;
    BSTNode(string value,int nwier, BSTNode *lSon=NULL, BSTNode *rSon = NULL){
    this->value=value;
    this->lSon=lSon;
    this->rSon=rSon;
    list.dodawanie(nwier);
}
};

class BSTTree{
private:
    BSTNode *root;
    void inorder(BSTNode*root);

    bool searchElement(BSTNode*root, string element,int nwier){
        if (root != NULL){
            if(root->value.compare(element)==0){
                root->list.dodawanie(nwier);
                return true;}
            else if(root->value.compare( element)>0)
                return(searchElement(root ->lSon, element,nwier));
                 else
                return(searchElement(root ->rSon, element,nwier));
        }
        return false;

        }

    BSTNode* insertElement(BSTNode *root, string n,int nwier){
        if(root!= NULL){
        if(root -> value.compare(n)>0){
                root->rSon =insertElement(root ->rSon, n,nwier);
                return root;

            }
            else if(root -> value .compare(n)<0){
                root ->lSon = insertElement(root -> lSon, n,nwier);
                return root;
            }
            else {

                return root;
            }
        }
            else{
                root = new BSTNode(n,nwier);
                return root;
            }
    }

public:
     BSTTree(){
         root = NULL;

         }
     bool IsEmpty(){
         if (root == NULL) return true;
         return false;
         }
     void inorder();

     bool searchElement(string element,int nwier){

         return searchElement(root, element,nwier);
         }


     void insertElement(string n,int x){

         root = insertElement(root, n,x);
         }

};






void BSTTree::inorder(BSTNode*root){
if(root != NULL){
     inorder(root -> lSon);
     cout << root -> value << " "<<"=> ";root->list.wyswietlanie();cout<<endl;
     inorder(root ->rSon);

}
}



void BSTTree::inorder(){
    inorder(root);
}











int main(){

string temp="";
   int ilwier,ilslow;
    BSTTree tree;
    cin>>ilwier;
    for(int i=0;i<ilwier;i++){
        cin>>ilslow;
        for(int j=0;j<ilslow;j++){
           // temp="";
           // cin.sync();
            cin>>temp;
            if(!tree.searchElement(temp,i+1)){

                tree.insertElement(temp,i+1);

            }

        }
    }
tree.inorder();

    return 0;
}
